{
  "name": "rtc-signaller",
  "version": "1.2.3",
  "description": "rtc.io transportless signalling for WebRTC",
  "main": "index.js",
  "directories": {
    "test": "test"
  },
  "dependencies": {
    "uuid": "~1.4.1",
    "cog": "~0.5.1",
    "collections": "^1",
    "rtc-core": "^1"
  },
  "devDependencies": {
    "tape": "^2",
    "rtc-switchboard": "^0.10.1",
    "messenger-memory": "^1",
    "testling": "^1",
    "fdom": "^0.8.0",
    "async": "~0.6"
  },
  "scripts": {
    "test": "node test/all.js && testling -x ./.travis/start-$BROWSER.sh",
    "gendocs": "gendocs > README.md"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/rtc-io/rtc-signaller.git"
  },
  "keywords": [
    "rtc.io",
    "webrtc",
    "signalling"
  ],
  "author": {
    "name": "Damon Oehlman",
    "email": "damon.oehlman@nicta.com.au"
  },
  "license": "Apache 2.0",
  "bugs": {
    "url": "https://github.com/rtc-io/rtc-signaller/issues"
  },
  "testling": {
    "files": "test/all.js",
    "server": "test/server.js"
  },
  "contributors": [
    {
      "name": "Damon Oehlman",
      "email": "damon.oehlman@nicta.com.au",
      "url": "https://github.com/DamonOehlman"
    },
    {
      "name": "Silvia Pfeiffer",
      "email": "silvia.pfeiffer@nicta.com.au",
      "url": "https://github.com/silviapfeiffer"
    }
  ],
  "readme": "# rtc-signaller\n\nThe `rtc-signaller` module provides a transportless signalling\nmechanism for WebRTC.\n\n\n[![NPM](https://nodei.co/npm/rtc-signaller.png)](https://nodei.co/npm/rtc-signaller/)\n\n[![Build Status](https://img.shields.io/travis/rtc-io/rtc-signaller.svg?branch=master)](https://travis-ci.org/rtc-io/rtc-signaller)\n![stable](https://img.shields.io/badge/stability-stable-green.svg)\n\n[![Gitter chat](https://badges.gitter.im/rtc-io/discuss.png)](https://gitter.im/rtc-io/discuss)\n\n\n## Purpose\n\nThe signaller provides set of client-side tools that assist with the\nsetting up an `PeerConnection` and helping them communicate. All that is\nrequired for the signaller to operate is a suitable messenger.\n\nA messenger is a simple object that implements node\n[EventEmitter](http://nodejs.org/api/events.html) style `on` events for\n`open`, `close`, `message` events, and also a `send` method by which\ndata will be send \"over-the-wire\".\n\nBy using this approach, we can conduct signalling over any number of\nmechanisms:\n\n- local, in memory message passing\n- via WebSockets and higher level abstractions (such as\n  [primus](https://github.com/primus/primus))\n- also over WebRTC data-channels (very meta, and admittedly a little\n  complicated).\n\n## Getting Started\n\nWhile the signaller is capable of communicating by a number of different\nmessengers (i.e. anything that can send and receive messages over a wire)\nit comes with support for understanding how to connect to an\n[rtc-switchboard](https://github.com/rtc-io/rtc-switchboard) out of the box.\n\nThe following code sample demonstrates how:\n\n```js\n// create a new signaller, connecting to the target switchboard\nvar signaller = require('rtc-signaller')('http://rtc.io/switchboard');\n\n// when a new peer is announced, log it\nsignaller.on('peer:announce', function(data) {\n console.log('new peer found in room: ', data);\n});\n\nsignaller.on('peer:disconnected', function(id) {\n  console.log('peer ' + id + ' has been disconnected');\n});\n\n// when a peer leaves the switchboard, log it\nsignaller.on('peer:leave', function(id) {\n  console.log('peer ' + id + ' has left the room');\n});\n\n// for our sanity, pop a message once we are connected\nsignaller.once('connected', function() {\n  console.log('we have successfully connected');\n});\n\n// send through an announce message\n// this will occur once the primus socket has been opened and active\nsignaller.announce({ room: 'signaller-getting-started' });\n```\n\n## Signaller Events\n\nThere is a number of events that are generating throughout the lifecycle of a signaller.  These events are derived from events and states that are generated by the underlying messenger used by the signaller.  In most cases this is a [primus](https://github.com/primus/primus) websocket connection (or spark).\n\n### Events regarding local state\n\nThe following events are generated by the signaller in response to updates n it's own state:\n\n- `connected`\n\nA connection has been established via the underlying messenger to a signalling server (or equivalent).\n\n- `disconnected`\n\nThe connection has been lost (possibly temporarily) with the signalling server (or transport).  It is possible that the connection will be re-established so this does not necessarily mean the end.\n\n### Events regarding peer state\n\nThe following events relate to information that has been relayed to this signaller about other peers:\n\n- `peer:filter`\n\nThe `peer:filter` event is triggered prior to the `peer:announce` or `peer:update` events being fired and provides an application the opportunity to reject a peer.  The handler for this event is passed a JS object that contains a `data` attribute for the announce data, and an `allow` flag that controls whether the peer is to be accepted.\n\nDue to the way event emitters behave in node, the last handler invoked is the authority on whether the peer is accepted or not (so make sure to check the previous state of the allow flag):\n\n  ```js\n  // only accept connections from Bob\n  signaller.on('peer:filter', function(evt) {\n    evt.allow = evt.allow && (evt.data.name === 'Bob');\n  });\n  ```\n\n__NOTE:__ This event handler does use a different syntax in the handler which provides application developers the opportunity to modify data from the event (in this case the `allow` attribute).\n\n- `peer:connected`\n\nIf a peer has passed the `peer:filter` test (either no filtering has been applied, or the allow flag is set to true in the filter events) then a `peer:connected` event will be emitted:\n\n  ```js\n  signaller.on('peer:connected', function(id) {\n    console.log('peer ' + id + ' has connected');\n  });\n  ```\n\nThe primary use case for this event is if you are updating part of your application UI to flag in response to a `peer:disconnected` event being fired (which can be due to poor network connectivity), then you can use the `peer:connected` event to restore UI elements to represent an active connection on receiving this event.\n\n- `peer:announce`\n\nWhile the `peer:connected` event is triggered each time a peer reconnects and announces to the signalling server, a `peer:announce` event is only emitted by your local signaller if this is considered a new connection from a peer.\n\nIf you are writing a WebRTC application, then this event is the best place to start creating `RTCPeerConnection` objects between the local machine and your remote, announced counterpart.  You will then be able to [couple](https://github.com/rtc-io/rtc#rtccouple) those connections together using the signaller.\n\n  ```js\n  signaller.on('peer:announce', function(data) {\n    console.log('discovered new peer: ' + data.id, data);\n\n    // TODO: create a peer connection with our new friend :)\n  });\n  ```\n\n- `peer:update`\n\nAn existing peer in the system has been \"re-announced\" possibly with some data changes:\n\n  ```js\n  signaller.on('peer:update', function(data) {\n    console.log('data update from peer: ' + data.id, data);\n  });\n  ```\n\n- `peer:disconnected`\n\nA peer has disconnected from the signalling server, but may reconnect if it manages to re-establish connectivity.\n\n  ```js\n  signaller.on('peer:disconnected', function(id) {\n    console.log('peer ' + id + ' has gone, but they might be back...');\n  });\n  ```\n\n- `peer:leave`\n\nThis event is triggered when the signaller has previously received a disconnection notification for a peer, and a reconnection has not been made by that peer within a certain time interval.\n\nThe default `leaveTimeout` is configured in the [defaults](https://github.com/rtc-io/rtc-signaller/blob/master/defaults.js) but can be overriden by passing configuration options when creating the signaller.\n\n  ```js\n  signaller.on('peer:leave', function(id) {\n    console.log('peer ' + id + ' has left :(');\n  });\n  ```\n\n\n## Signal Flow Diagrams\n\nDisplayed below are some diagrams how the signalling flow between peers behaves.  In each of the diagrams we illustrate three peers (A, B and C) participating discovery and coordinating RTCPeerConnection handshakes.\n\nIn each case, only the interaction between the clients is represented not how a signalling server (such as [rtc-switchboard](https://github.com/rtc-io/rtc-switchboard)) would pass on broadcast messages, etc.  This is done for two reasons:\n\n  1. It is out of scope of this documentation.\n  2. The `rtc-signaller` has been designed to work without having to rely on any intelligence in the server side signalling component.  In the instance that a signaller broadcasts all messages to all connected peers then `rtc-signaller` should be smart enough to make sure everything works as expected.\n\n### Peer Discovery / Announcement\n\nThis diagram illustrates the process of how peer `A` announces itself to peers `B` and `C`, and in turn they announce themselves.\n\n![](https://raw.github.com/rtc-io/rtc-signaller/master/docs/announce.png)\n\n### Editing / Updating the Diagrams\n\nEach of the diagrams has been generated using [mscgen](http://www.mcternan.me.uk/mscgen/index.html) and the source for these documents can be found in the `docs/` folder of this repository.\n\n\n## Reference\n\nThe `rtc-signaller` module is designed to be used primarily in a functional\nway and when called it creates a new signaller that will enable\nyou to communicate with other peers via your messaging network.\n\n```js\n// create a signaller from something that knows how to send messages\nvar signaller = require('rtc-signaller')(messenger);\n```\n\nAs demonstrated in the getting started guide, you can also pass through\na string value instead of a messenger instance if you simply want to\nconnect to an existing `rtc-switchboard` instance.\n\n### signaller#send(message, data*)\n\nUse the send function to send a message to other peers in the current\nsignalling scope (if announced in a room this will be a room, otherwise\nbroadcast to all peers connected to the signalling server).\n\n### announce(data?)\n\nThe `announce` function of the signaller will pass an `/announce` message\nthrough the messenger network.  When no additional data is supplied to\nthis function then only the id of the signaller is sent to all active\nmembers of the messenging network.\n\n#### Joining Rooms\n\nTo join a room using an announce call you simply provide the name of the\nroom you wish to join as part of the data block that you annouce, for\nexample:\n\n```js\nsignaller.announce({ room: 'testroom' });\n```\n\nSignalling servers (such as\n[rtc-switchboard](https://github.com/rtc-io/rtc-switchboard)) will then\nplace your peer connection into a room with other peers that have also\nannounced in this room.\n\nOnce you have joined a room, the server will only deliver messages that\nyou `send` to other peers within that room.\n\n#### Providing Additional Announce Data\n\nThere may be instances where you wish to send additional data as part of\nyour announce message in your application.  For instance, maybe you want\nto send an alias or nick as part of your announce message rather than just\nuse the signaller's generated id.\n\nIf for instance you were writing a simple chat application you could join\nthe `webrtc` room and tell everyone your name with the following announce\ncall:\n\n```js\nsignaller.announce({\n  room: 'webrtc',\n  nick: 'Damon'\n});\n```\n\n#### Announcing Updates\n\nThe signaller is written to distinguish between initial peer announcements\nand peer data updates (see the docs on the announce handler below). As\nsuch it is ok to provide any data updates using the announce method also.\n\nFor instance, I could send a status update as an announce message to flag\nthat I am going offline:\n\n```js\nsignaller.announce({ status: 'offline' });\n```\n\n### isMaster(targetId)\n\nA simple function that indicates whether the local signaller is the master\nfor it's relationship with peer signaller indicated by `targetId`.  Roles\nare determined at the point at which signalling peers discover each other,\nand are simply worked out by whichever peer has the lowest signaller id\nwhen lexigraphically sorted.\n\nFor example, if we have two signaller peers that have discovered each\nothers with the following ids:\n\n- `b11f4fd0-feb5-447c-80c8-c51d8c3cced2`\n- `8a07f82e-49a5-4b9b-a02e-43d911382be6`\n\nThey would be assigned roles:\n\n- `b11f4fd0-feb5-447c-80c8-c51d8c3cced2`\n- `8a07f82e-49a5-4b9b-a02e-43d911382be6` (master)\n\n### leave()\n\nTell the signalling server we are leaving.  Calling this function is\nusually not required though as the signalling server should issue correct\n`/leave` messages when it detects a disconnect event.\n\n### metadata(data?)\n\nGet (pass no data) or set the metadata that is passed through with each\nrequest sent by the signaller.\n\n__NOTE:__ Regardless of what is passed to this function, metadata\ngenerated by the signaller will **always** include the id of the signaller\nand this cannot be modified.\n\n### to(targetId)\n\nUse the `to` function to send a message to the specified target peer.\nA large parge of negotiating a WebRTC peer connection involves direct\ncommunication between two parties which must be done by the signalling\nserver.  The `to` function provides a simple way to provide a logical\ncommunication channel between the two parties:\n\n```js\nvar send = signaller.to('e95fa05b-9062-45c6-bfa2-5055bf6625f4').send;\n\n// create an offer on a local peer connection\npc.createOffer(\n  function(desc) {\n    // set the local description using the offer sdp\n    // if this occurs successfully send this to our peer\n    pc.setLocalDescription(\n      desc,\n      function() {\n        send('/sdp', desc);\n      },\n      handleFail\n    );\n  },\n  handleFail\n);\n```\n\n### loadPrimus(signalhost, callback)\n\nThis is a convenience function that is patched into the signaller to assist\nwith loading the `primus.js` client library from an `rtc-switchboard`\nsignaling server.\n\n### signaller process handling\n\nWhen a signaller's underling messenger emits a `data` event this is\ndelegated to a simple message parser, which applies the following simple\nlogic:\n\n- Is the message a `/to` message. If so, see if the message is for this\n  signaller (checking the target id - 2nd arg).  If so pass the\n  remainder of the message onto the standard processing chain.  If not,\n  discard the message.\n\n- Is the message a command message (prefixed with a forward slash). If so,\n  look for an appropriate message handler and pass the message payload on\n  to it.\n\n- Finally, does the message match any patterns that we are listening for?\n  If so, then pass the entire message contents onto the registered handler.\n\n### signaller message handlers\n\n#### announce\n\n```\n/announce|%metadata%|{\"id\": \"...\", ... }\n```\n\nWhen an announce message is received by the signaller, the attached\nobject data is decoded and the signaller emits an `announce` message.\n\n#### leave\n\n```\n/leave|{\"id\":\"...\"}\n```\n\nWhen a leave message is received from a peer, we check to see if that is\na peer that we are managing state information for and if we are then the\npeer state is removed.\n\n## License(s)\n\n### Apache 2.0\n\nCopyright 2013 - 2014 National ICT Australia Limited (NICTA)\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/rtc-io/rtc-signaller",
  "_id": "rtc-signaller@1.2.3",
  "_from": "rtc-signaller@^1"
}
