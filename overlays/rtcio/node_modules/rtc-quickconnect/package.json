{
  "name": "rtc-quickconnect",
  "version": "1.0.3",
  "description": "Create a WebRTC connection in record time",
  "main": "index.js",
  "scripts": {
    "test": "testling -x ./.travis/start-$BROWSER.sh",
    "gendocs": "gendocs > README.md"
  },
  "repository": {
    "type": "git",
    "url": "https://github.com/rtc-io/rtc-quickconnect.git"
  },
  "keywords": [
    "rtc.io",
    "webrtc"
  ],
  "author": {
    "name": "Damon Oehlman",
    "email": "damon.oehlman@nicta.com.au"
  },
  "license": "Apache 2.0",
  "bugs": {
    "url": "https://github.com/rtc-io/rtc-quickconnect/issues"
  },
  "dependencies": {
    "rtc": "^1",
    "cog": "^0.5.2",
    "rtc-signaller": "^1",
    "rtc-core": "^1",
    "collections": "^1"
  },
  "devDependencies": {
    "crel": "^1",
    "rtc-media": "^1",
    "tape": "^2",
    "rtc-switchboard": "^0.10.1",
    "uuid": "~1.4.1",
    "rtc-videoproc": "^0.11.0",
    "rtc-captureconfig": "~0.4.0",
    "rtc-bufferedchannel": "^0.5.0",
    "rtc-filter-grayscale": "~0.1.0",
    "async": "^0.6.2",
    "freeice": "~0.2.1",
    "testling": "^1.6.1"
  },
  "testling": {
    "files": "test/all.js",
    "server": "test/server.js"
  },
  "contributors": [
    {
      "name": "Damon Oehlman",
      "email": "damon.oehlman@nicta.com.au",
      "url": "https://github.com/DamonOehlman"
    },
    {
      "name": "Silvia Pfeiffer",
      "email": "silvia.pfeiffer@nicta.com.au",
      "url": "https://github.com/silviapfeiffer"
    }
  ],
  "readme": "# rtc-quickconnect\n\nThis is a high level helper module designed to help you get up\nan running with WebRTC really, really quickly.  By using this module you\nare trading off some flexibility, so if you need a more flexible\nconfiguration you should drill down into lower level components of the\n[rtc.io](http://www.rtc.io) suite.  In particular you should check out\n[rtc](https://github.com/rtc-io/rtc).\n\n\n[![NPM](https://nodei.co/npm/rtc-quickconnect.png)](https://nodei.co/npm/rtc-quickconnect/)\n\n[![Build Status](https://img.shields.io/travis/rtc-io/rtc-quickconnect.svg?branch=master)](https://travis-ci.org/rtc-io/rtc-quickconnect)\n![unstable](https://img.shields.io/badge/stability-unstable-yellowgreen.svg)\n\n[![Gitter chat](https://badges.gitter.im/rtc-io/discuss.png)](https://gitter.im/rtc-io/discuss)\n\n\n## Upgrading to 1.0\n\nThe [upgrading to 1.0 documentation](https://github.com/rtc-io/rtc-quickconnect/blob/master/docs/upgrading-to-1.0.md)\nprovides some information on what you need to change to upgrade to\n`rtc-quickconnect@1.0`.  Additionally, the\n[quickconnect demo app](https://github.com/rtc-io/rtcio-demo-quickconnect)\nhas been updated which should provide some additional information.\n\n## Example Usage\n\nIn the simplest case you simply call quickconnect with a single string\nargument which tells quickconnect which server to use for signaling:\n\n```js\nvar quickconnect = require('rtc-quickconnect');\n\nquickconnect('http://rtc.io/switchboard/', { room: 'qc-simple-demo' })\n  .on('call:started', function(id, pc, data) {\n    console.log('we have a new connection to: ' + id);\n  });\n```\n\n## Events\n\nThe following events are emitted from the signalling object created by\ncalling `quickconnect()`:\n\n### Call Level Events\n\nA \"call\" in quickconnect is equivalent to an established `RTCPeerConnection`\nbetween this quickconnect instance a remote peer.\n\n- `call:started => function(id, peerconnection, data)`\n\n  Triggered once a peer connection has been established been established\n  between this quickconnect instance and another.\n\n- `call:ended => function(id)`\n\n  Triggered when a peer connection has been closed.  This may be due to the\n  peer connection itself indicating that it has been closed, or we may have\n  lost connection with the remote signaller and the connection has timed out.\n\n### Data Channel Level Events\n\n- `channel:opened => function(id, datachannel, data)`\n\n  The `channel:opened` event is triggered whenever an `RTCDataChannel` has\n  been opened (it's ready to send data) to a remote peer.\n\n- `channel:opened:%label% => function(id, datachannel, data)`\n\n  This is equivalent of the `channel:opened` event, but only triggered for\n  a channel with label `%label%`.  For example:\n\n  ```js\n  quickconnect('http://rtc.io/switchboard', { room: 'test' })\n    .createDataChannel('foo')\n    .createDataChannel('bar')\n    .on('channel:opened:foo', function(id, dc) {\n      console.log('channel foo opened for peer: ' + id);\n    });\n  ```\n\n  In the case above the console message would only be displayed for the\n  `foo` channel once open, and when the `bar` channel is opened no handler\n  would be invoked.\n\n- `channel:closed => function(id, label)`\n\n  Emitted when the channel has been closed, works when a connection has\n  been closed or the channel itself has been closed.\n\n- `channel:closed:%label% => function(id, label)`\n\n  The label specific equivalent of `channel:closed`.\n\n### Stream Level Events\n\n- `stream:added => function(id, stream, data)`\n\n  The `stream:added` event is triggered when an `RTCPeerConnection` has\n  successfully been established to another peer that contains remote\n  streams.  Additionally, if you are using quickconnect in it's \"reactive\"\n  mode then you will also receive `stream:added` events as streams are\n  dynamically added to the connection by the remote peer.\n\n- `stream:removed => function(id)`\n\n  As per the `stream:added` event but triggered when a stream has been\n  removed.\n\n## Example Usage (using data channels)\n\nWhen working with WebRTC data channels, you can call the `createDataChannel`\nfunction helper that is attached to the object returned from the\n`quickconnect` call.  The `createDataChannel` function signature matches\nthe signature of the `RTCPeerConnection` `createDataChannel` function.\n\nAt the minimum it requires a label for the channel, but you can also pass\nthrough a dictionary of options that can be used to fine tune the\ndata channel behaviour.  For more information on these options, I'd\nrecommend having a quick look at the WebRTC spec:\n\nhttp://dev.w3.org/2011/webrtc/editor/webrtc.html#dictionary-rtcdatachannelinit-members\n\nIf in doubt, I'd recommend not passing through options.\n\n```js\nvar freeice = require('freeice');\nvar quickconnect = require('rtc-quickconnect');\nvar opts = {\n  room: 'qcexample-dctest',\n  // debug: true,\n  iceServers: freeice()\n};\n\nquickconnect('http://rtc.io/switchboard/', opts)\n  // tell quickconnect we want a datachannel called test\n  .createDataChannel('test')\n  // when the test channel is open, let us know\n  .on('channel:opened:test', function(id, dc) {\n    dc.onmessage = function(evt) {\n      console.log('peer ' + id + ' says: ' + evt.data);\n    };\n\n    console.log('test dc open for peer: ' + id);\n    dc.send('hi');\n  });\n```\n\n__NOTE:__ Data channel interoperability has been tested between Chrome 32\nand Firefox 26, which both make use of SCTP data channels.\n\n__NOTE:__ The current stable version of Chrome is 31, so interoperability\nwith Firefox right now will be hard to achieve.\n\n## Example Usage (using captured media)\n\nAnother example is displayed below, and this example demonstrates how\nto use `rtc-quickconnect` to create a simple video conferencing application:\n\n```js\nvar quickconnect = require('rtc-quickconnect');\nvar media = require('rtc-media');\nvar crel = require('crel');\n\n// create containers for our local and remote video\nvar local = crel('div', { class: 'local' });\nvar remote = crel('div', { class: 'remote' });\nvar media  \nvar peerMedia = {};\n\n// capture local media\nvar localMedia = media();\n\n// require('cog/logger').enable('*');\n\n// once media is captured, connect\nlocalMedia.once('capture', function(stream) {\n  quickconnect('http://rtc.io/switchboard/', { room: 'conftest' })\n    // broadcast our captured media to other participants in the room\n    .addStream(stream)\n    // when a peer is connected (and active) pass it to us for use\n    .on('call:started', function(id, pc, data) {\n      console.log('peer connected: ', id);\n\n      // render the remote streams\n      pc.getRemoteStreams().forEach(renderRemote(id));\n    })\n    // when a peer leaves, remove teh media\n    .on('call:ended', function(id) {\n      // remove media for the target peer from the dom\n      (peerMedia[id] || []).splice(0).forEach(function(el) {\n        el.parentNode.removeChild(el);\n      });\n    })\n});\n\n// render the local media\nlocalMedia.render(local);\n\n// render a remote video\nfunction renderRemote(id) {\n  // create the peer media list\n  peerMedia[id] = peerMedia[id] || [];\n\n  return function(stream) {\n    peerMedia[id] = peerMedia[id].concat(media(stream).render(remote));\n  }\n}\n\n/* extra code to handle dynamic html and css creation */\n\n// add some basic styling\ndocument.head.appendChild(crel('style', [\n  '.local { position: absolute;  right: 10px; }',\n  '.local video { max-width: 200px; }'\n].join('\\n')));\n\n// add the local and remote elements\ndocument.body.appendChild(local);\ndocument.body.appendChild(remote);\n```\n\n## Regarding Signalling and a Signalling Server\n\nSignaling is an important part of setting up a WebRTC connection and for\nour examples we use our own test instance of the\n[rtc-switchboard](https://github.com/rtc-io/rtc-switchboard). For your\ntesting and development you are more than welcome to use this also, but\njust be aware that we use this for our testing so it may go up and down\na little.  If you need something more stable, why not consider deploying\nan instance of the switchboard yourself - it's pretty easy :)\n\n## Reference\n\n```\nquickconnect(signalhost, opts?) => rtc-sigaller instance (+ helpers)\n```\n\n### Valid Quick Connect Options\n\nThe options provided to the `rtc-quickconnect` module function influence the\nbehaviour of some of the underlying components used from the rtc.io suite.\n\nListed below are some of the commonly used options:\n\n- `ns` (default: '')\n\n  An optional namespace for your signalling room.  While quickconnect\n  will generate a unique hash for the room, this can be made to be more\n  unique by providing a namespace.  Using a namespace means two demos\n  that have generated the same hash but use a different namespace will be\n  in different rooms.\n\n- `room` (default: null) _added 0.6_\n\n  Rather than use the internal hash generation\n  (plus optional namespace) for room name generation, simply use this room\n  name instead.  __NOTE:__ Use of the `room` option takes precendence over\n  `ns`.\n\n- `debug` (default: false)\n\nWrite rtc.io suite debug output to the browser console.\n\n#### Options for Peer Connection Creation\n\nOptions that are passed onto the\n[rtc.createConnection](https://github.com/rtc-io/rtc#createconnectionopts-constraints)\nfunction:\n\n- `iceServers`\n\nThis provides a list of ice servers that can be used to help negotiate a\nconnection between peers.\n\n#### Options for P2P negotiation\n\nUnder the hood, quickconnect uses the\n[rtc/couple](https://github.com/rtc-io/rtc#rtccouple) logic, and the options\npassed to quickconnect are also passed onto this function.\n\n### Quickconnect Broadcast and Data Channel Helper Functions\n\nThe following are functions that are patched into the `rtc-signaller`\ninstance that make working with and creating functional WebRTC applications\na lot simpler.\n\n#### addStream\n\n```\naddStream(stream:MediaStream) => qc\n```\n\nAdd the stream to active calls and also save the stream so that it\ncan be added to future calls.\n\n#### close()\n\nThe `close` function provides a convenient way of closing all associated\npeer connections.\n\n#### createDataChannel(label, config)\n\nRequest that a data channel with the specified `label` is created on\nthe peer connection.  When the data channel is open and available, an\nevent will be triggered using the label of the data channel.\n\nFor example, if a new data channel was requested using the following\ncall:\n\n```js\nvar qc = quickconnect('http://rtc.io/switchboard').createDataChannel('test');\n```\n\nThen when the data channel is ready for use, a `test:open` event would\nbe emitted by `qc`.\n\n#### reactive()\n\nFlag that this session will be a reactive connection.\n\n#### removeStream\n\n```\nremoveStream(stream:MediaStream)\n```\n\nRemove the specified stream from both the local streams that are to \nbe connected to new peers, and also from any active calls.\n\n#### requestChannel\n\n```\nrequestChannel(targetId, label, callback)\n```\n\nThis is a function that can be used to respond to remote peers supplying\na data channel as part of their configuration.  As per the `receiveStream`\nfunction this function will either fire the callback immediately if the\nchannel is already available, or once the channel has been discovered on\nthe call.\n\n#### requestStream\n\n```\nrequestStream(targetId, idx, callback)\n```\n\nUsed to request a remote stream from a quickconnect instance. If the\nstream is already available in the calls remote streams, then the callback\nwill be triggered immediately, otherwise this function will monitor\n`stream:added` events and wait for a match.\n\nIn the case that an unknown target is requested, then an exception will\nbe thrown.\n\n#### profile(data)\n\nUpdate the profile data with the attached information, so when \nthe signaller announces it includes this data in addition to any\nroom and id information.\n\n#### waitForCall\n\n```\nwaitForCall(targetId, callback)\n```\n\nWait for a call from the specified targetId.  If the call is already\nactive the callback will be fired immediately, otherwise we will wait\nfor a `call:started` event that matches the requested `targetId`\n\n## License(s)\n\n### Apache 2.0\n\nCopyright 2014 National ICT Australia Limited (NICTA)\n\n   Licensed under the Apache License, Version 2.0 (the \"License\");\n   you may not use this file except in compliance with the License.\n   You may obtain a copy of the License at\n\n     http://www.apache.org/licenses/LICENSE-2.0\n\n   Unless required by applicable law or agreed to in writing, software\n   distributed under the License is distributed on an \"AS IS\" BASIS,\n   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n   See the License for the specific language governing permissions and\n   limitations under the License.\n",
  "readmeFilename": "README.md",
  "homepage": "https://github.com/rtc-io/rtc-quickconnect",
  "_id": "rtc-quickconnect@1.0.3",
  "dist": {
    "shasum": "5ac7cc29deb5ee0a82393a6322d66afb13fc176d"
  },
  "_from": "rtc-quickconnect@^1.0.0",
  "_resolved": "https://registry.npmjs.org/rtc-quickconnect/-/rtc-quickconnect-1.0.3.tgz"
}
